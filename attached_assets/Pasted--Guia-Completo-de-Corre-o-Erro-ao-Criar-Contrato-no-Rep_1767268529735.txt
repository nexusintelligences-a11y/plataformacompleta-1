# Guia Completo de Corre√ß√£o: Erro ao Criar Contrato no Replit

Este documento consolida todas as informa√ß√µes t√©cnicas necess√°rias para diagnosticar e corrigir o erro de cria√ß√£o de contratos na plataforma.

---

## üéØ ETAPA 1: DIAGN√ìSTICO INICIAL

### 1.1 Capturar o Erro Real
Antes de qualquer corre√ß√£o, precisamos ver o erro exato. Adicione logs detalhados:

**No Frontend (`client/src/components/admin/ContractForm.tsx` ou similar):**
```typescript
const handleSubmit = async (data) => {
  console.log("üì§ DADOS ENVIADOS:", JSON.stringify(data, null, 2));
  
  try {
    const response = await fetch("/api/contracts", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data)
    });
    
    console.log("üìä STATUS RESPOSTA:", response.status);
    
    if (!response.ok) {
      const errorData = await response.json();
      console.error("‚ùå ERRO DO SERVIDOR:", errorData);
      throw new Error(errorData.error || "Erro desconhecido");
    }
    
    const result = await response.json();
    console.log("‚úÖ CONTRATO CRIADO:", result);
    
  } catch (error) {
    console.error("‚ùå ERRO CAPTURADO:", error);
    alert(`Erro: ${error.message}`);
  }
};
```

**No Backend (`server/routes.ts`):**
```typescript
app.post("/api/contracts", async (req, res) => {
  console.log("=" .repeat(80));
  console.log("üîç RECEBENDO REQUISI√á√ÉO DE CRIA√á√ÉO DE CONTRATO");
  console.log("üì• Body recebido:", JSON.stringify(req.body, null, 2));
  console.log("=" .repeat(80));
  
  try {
    // Valida√ß√£o com Zod
    const validatedData = insertContractSchema.parse(req.body);
    console.log("‚úÖ Dados validados com sucesso:", validatedData);
    
    // Cria√ß√£o no banco
    const contract = await storage.createContract(validatedData);
    console.log("‚úÖ Contrato criado no banco:", contract);
    
    res.status(201).json(contract);
    
  } catch (error) {
    console.error("=" .repeat(80));
    console.error("‚ùå ERRO AO CRIAR CONTRATO:");
    console.error("Tipo:", error.constructor.name);
    console.error("Mensagem:", error.message);
    console.error("Stack:", error.stack);
    
    if (error.name === 'ZodError') {
      console.error("üî¥ Erros de Valida√ß√£o Zod:", JSON.stringify(error.errors, null, 2));
      return res.status(400).json({ 
        error: "Dados inv√°lidos", 
        details: error.errors 
      });
    }
    
    console.error("=" .repeat(80));
    res.status(500).json({ 
      error: "Erro interno do servidor",
      message: error.message,
      type: error.constructor.name
    });
  }
});
```

### 1.2 Executar Teste
1. Abra o console do navegador (F12)
2. Tente criar um contrato
3. Copie TODOS os logs que aparecerem (frontend e backend)
4. Anote o **status code** da resposta (400, 500, etc)

---

## üîß ETAPA 2: VERIFICA√á√ÉO DO SCHEMA ZOD

### 2.1 Schema Completo Esperado
Verifique se o arquivo `shared/schema.ts` tem exatamente isto:

```typescript
import { z } from "zod";

// Schema de valida√ß√£o para inser√ß√£o de contrato
export const insertContractSchema = z.object({
  // Campos obrigat√≥rios do cliente
  client_name: z.string().min(1, "Nome √© obrigat√≥rio"),
  client_cpf: z.string()
    .min(11, "CPF deve ter 11 d√≠gitos")
    .regex(/^\d{11}$/, "CPF deve conter apenas n√∫meros"),
  client_email: z.string()
    .email("Email inv√°lido"),
  
  // Campos opcionais de contato
  client_phone: z.string().optional(),
  client_address: z.string().optional(),
  client_city: z.string().optional(),
  client_state: z.string().optional(),
  client_zip: z.string().optional(),
  
  // Conte√∫do do contrato
  contract_html: z.string().min(1, "Conte√∫do do contrato √© obrigat√≥rio"),
  
  // Campos de personaliza√ß√£o (opcionais)
  logo_url: z.string().url().optional().or(z.literal("")),
  primary_color: z.string().regex(/^#[0-9A-Fa-f]{6}$/).optional(),
  text_color: z.string().regex(/^#[0-9A-Fa-f]{6}$/).optional(),
  font_family: z.string().optional(),
  company_name: z.string().optional(),
  footer_text: z.string().optional(),
  
  // Configura√ß√µes de verifica√ß√£o
  verification_instructions: z.string().optional(),
  security_message: z.string().optional(),
  header_background_color: z.string().optional(),
  
  // Tracker de progresso
  progress_step1_text: z.string().optional(),
  progress_step2_text: z.string().optional(),
  progress_step3_text: z.string().optional(),
  progress_step4_text: z.string().optional(),
  
  // Tela de sucesso
  success_title: z.string().optional(),
  success_message: z.string().optional(),
  success_button_text: z.string().optional(),
  
  // Links de apps
  app_store_url: z.string().url().optional().or(z.literal("")),
  play_store_url: z.string().url().optional().or(z.literal("")),
});

export type InsertContract = z.infer<typeof insertContractSchema>;
```

### 2.2 Valida√ß√£o de CPF
Se o frontend envia CPF formatado (000.000.000-00), adicione tratamento:

```typescript
// No frontend, antes de enviar:
const cleanCPF = (cpf: string) => cpf.replace(/\D/g, '');

const submitData = {
  ...formData,
  client_cpf: cleanCPF(formData.client_cpf)
};
```

---

## üóÑÔ∏è ETAPA 3: VERIFICA√á√ÉO DO BANCO DE DADOS

### 3.1 Schema SQL Completo
Execute este SQL no PostgreSQL do Replit para garantir todas as colunas:

```sql
-- Verifica se a tabela existe
SELECT table_name FROM information_schema.tables 
WHERE table_schema = 'public' AND table_name = 'contracts';

-- Cria ou atualiza a tabela com TODAS as colunas necess√°rias
CREATE TABLE IF NOT EXISTS contracts (
  id SERIAL PRIMARY KEY,
  
  -- Identifica√ß√£o
  access_token UUID DEFAULT gen_random_uuid() UNIQUE NOT NULL,
  
  -- Dados do cliente (OBRIGAT√ìRIOS)
  client_name VARCHAR(255) NOT NULL,
  client_cpf VARCHAR(20) NOT NULL,
  client_email VARCHAR(255) NOT NULL,
  
  -- Dados de contato (OPCIONAIS)
  client_phone VARCHAR(20),
  client_address TEXT,
  client_city VARCHAR(100),
  client_state VARCHAR(2),
  client_zip VARCHAR(10),
  
  -- Conte√∫do
  contract_html TEXT NOT NULL,
  
  -- Status e datas
  status VARCHAR(50) DEFAULT 'pending',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  signed_at TIMESTAMP,
  
  -- Verifica√ß√£o facial
  verification_selfie TEXT,
  verification_document TEXT,
  face_match_score DECIMAL(5,2),
  
  -- Personaliza√ß√£o - Apar√™ncia
  logo_url TEXT,
  primary_color VARCHAR(7) DEFAULT '#3B82F6',
  text_color VARCHAR(7) DEFAULT '#1F2937',
  font_family VARCHAR(100) DEFAULT 'Inter',
  company_name VARCHAR(255),
  footer_text TEXT,
  
  -- Personaliza√ß√£o - Verifica√ß√£o
  verification_instructions TEXT,
  security_message TEXT,
  header_background_color VARCHAR(7),
  
  -- Personaliza√ß√£o - Tracker
  progress_step1_text VARCHAR(255),
  progress_step2_text VARCHAR(255),
  progress_step3_text VARCHAR(255),
  progress_step4_text VARCHAR(255),
  
  -- Personaliza√ß√£o - Sucesso
  success_title VARCHAR(255),
  success_message TEXT,
  success_button_text VARCHAR(100),
  
  -- Links de apps
  app_store_url TEXT,
  play_store_url TEXT,
  
  -- Gov.br
  govbr_token_hash VARCHAR(255),
  govbr_cpf VARCHAR(20),
  govbr_validated BOOLEAN DEFAULT false
);

-- Adiciona colunas que podem estar faltando (se a tabela j√° existe)
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS access_token UUID DEFAULT gen_random_uuid() UNIQUE;
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS logo_url TEXT;
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS primary_color VARCHAR(7) DEFAULT '#3B82F6';
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS text_color VARCHAR(7) DEFAULT '#1F2937';
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS font_family VARCHAR(100) DEFAULT 'Inter';
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS company_name VARCHAR(255);
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS footer_text TEXT;
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS verification_instructions TEXT;
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS security_message TEXT;
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS header_background_color VARCHAR(7);
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS progress_step1_text VARCHAR(255);
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS progress_step2_text VARCHAR(255);
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS progress_step3_text VARCHAR(255);
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS progress_step4_text VARCHAR(255);
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS success_title VARCHAR(255);
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS success_message TEXT;
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS success_button_text VARCHAR(100);
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS app_store_url TEXT;
ALTER TABLE contracts ADD COLUMN IF NOT EXISTS play_store_url TEXT;

-- Verifica as colunas criadas
SELECT column_name, data_type, is_nullable, column_default
FROM information_schema.columns
WHERE table_name = 'contracts'
ORDER BY ordinal_position;
```

### 3.2 Sincroniza√ß√£o via Drizzle
Alternativamente, force a sincroniza√ß√£o:

```bash
npm run db:push --force
```

‚ö†Ô∏è **ATEN√á√ÉO**: Isso pode sobrescrever o schema. Fa√ßa backup antes!

---

## üíæ ETAPA 4: VERIFICA√á√ÉO DO STORAGE

### 4.1 Implementa√ß√£o Correta do createContract
Verifique o arquivo `server/storage.ts` ou `server/db.ts`:

```typescript
import { db } from "./db";
import { contracts, type InsertContract } from "@db/schema";

export async function createContract(data: InsertContract) {
  try {
    console.log("üíæ Inserindo no banco:", data);
    
    const [newContract] = await db
      .insert(contracts)
      .values(data)
      .returning();
    
    console.log("‚úÖ Contrato inserido com ID:", newContract.id);
    return newContract;
    
  } catch (error) {
    console.error("‚ùå Erro ao inserir no banco:", error);
    throw new Error(`Falha na inser√ß√£o: ${error.message}`);
  }
}
```

### 4.2 Teste Direto no Banco
Para testar se o banco aceita inser√ß√µes, execute:

```sql
INSERT INTO contracts (
  client_name, 
  client_cpf, 
  client_email, 
  contract_html
) VALUES (
  'Teste Manual',
  '12345678901',
  'teste@email.com',
  '<h1>Contrato de Teste</h1>'
) RETURNING *;
```

Se isso falhar, o problema est√° no schema do banco.

---

## üåê ETAPA 5: CONFIGURA√á√ïES DE AMBIENTE

### 5.1 Vari√°veis Obrigat√≥rias
Verifique no Replit (Secrets/Environment):

```bash
# Database
DATABASE_URL=postgresql://usuario:senha@host:porta/database

# Supabase (se usado)
REACT_APP_SUPABASE_URL=https://xxx.supabase.co
REACT_APP_SUPABASE_ANON_KEY=eyJxxx...

# Session
SESSION_SECRET=seu_secret_aqui_minimo_32_caracteres
```

### 5.2 Teste de Conex√£o
Adicione este endpoint tempor√°rio:

```typescript
app.get("/api/health", async (req, res) => {
  try {
    // Testa conex√£o com o banco
    const result = await db.execute(sql`SELECT NOW()`);
    
    res.json({
      status: "ok",
      database: "connected",
      timestamp: result.rows[0].now
    });
  } catch (error) {
    res.status(500).json({
      status: "error",
      database: "disconnected",
      error: error.message
    });
  }
});
```

Acesse: `https://seu-replit.repl.co/api/health`

---

## üîç ETAPA 6: DEBUGGING AVAN√áADO

### 6.1 Checklist de Verifica√ß√£o

```
[ ] Frontend: Logs mostram dados corretos sendo enviados?
[ ] Frontend: CPF est√° sem m√°scara (apenas n√∫meros)?
[ ] Frontend: Email tem formato v√°lido?
[ ] Backend: Endpoint /api/contracts existe e responde?
[ ] Backend: insertContractSchema valida os dados?
[ ] Backend: Erro √© 400 (valida√ß√£o) ou 500 (servidor)?
[ ] Banco: Tabela contracts existe?
[ ] Banco: Todas as colunas existem (query SELECT column_name)?
[ ] Banco: DATABASE_URL est√° correta?
[ ] Banco: Inser√ß√£o manual funciona?
[ ] Vite: Proxy est√° configurado (allowedHosts: true)?
[ ] CORS: Middleware cors() est√° ativo?
```

### 6.2 Teste Isolado
Crie um endpoint de teste simplificado:

```typescript
app.post("/api/test-insert", async (req, res) => {
  try {
    const testData = {
      client_name: "Teste Sistema",
      client_cpf: "12345678901",
      client_email: "teste@sistema.com",
      contract_html: "<h1>Teste</h1>"
    };
    
    const result = await db
      .insert(contracts)
      .values(testData)
      .returning();
    
    res.json({ success: true, contract: result[0] });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message,
      stack: error.stack
    });
  }
});
```

Se este endpoint funcionar, o problema est√° na valida√ß√£o ou nos dados enviados.

---

## üö® ETAPA 7: ERROS COMUNS E SOLU√á√ïES

### Erro: "CPF deve conter apenas n√∫meros"
**Causa**: Frontend enviando CPF formatado (000.000.000-00)
**Solu√ß√£o**: 
```typescript
client_cpf: formData.client_cpf.replace(/\D/g, '')
```

### Erro: "column 'xxx' does not exist"
**Causa**: Schema do banco desatualizado
**Solu√ß√£o**: Execute os ALTER TABLE do passo 3.1

### Erro: "cannot insert NULL into column"
**Causa**: Campo obrigat√≥rio n√£o est√° sendo enviado
**Solu√ß√£o**: Verifique se o frontend envia todos campos obrigat√≥rios (name, cpf, email, contract_html)

### Erro: "relation 'contracts' does not exist"
**Causa**: Tabela n√£o foi criada
**Solu√ß√£o**: Execute o CREATE TABLE do passo 3.1

### Erro: "CORS policy blocked"
**Causa**: Backend n√£o aceita requisi√ß√µes do frontend
**Solu√ß√£o**: Adicione no `server/index.ts`:
```typescript
import cors from "cors";
app.use(cors());
```

### Erro: "Invalid host header"
**Causa**: Vite bloqueando proxy no Replit
**Solu√ß√£o**: No `vite.config.ts`:
```typescript
server: {
  host: '0.0.0.0',
  allowedHosts: true
}
```

---

## üìã ETAPA 8: CHECKLIST FINAL

Ap√≥s aplicar as corre√ß√µes:

1. ‚úÖ Reinicie o servidor (`Ctrl+C` e `npm run dev`)
2. ‚úÖ Limpe o cache do navegador (Ctrl+Shift+Delete)
3. ‚úÖ Abra o console (F12) antes de testar
4. ‚úÖ Tente criar um contrato simples
5. ‚úÖ Verifique os logs do terminal e do console
6. ‚úÖ Se funcionar, teste com dados completos
7. ‚úÖ Verifique se o contrato aparece no banco:
   ```sql
   SELECT * FROM contracts ORDER BY created_at DESC LIMIT 5;
   ```

---

## üÜò PR√ìXIMOS PASSOS SE AINDA N√ÉO FUNCIONAR

Se ap√≥s seguir TODOS os passos o erro persistir, forne√ßa:

1. **Logs completos** do terminal do servidor
2. **Logs completos** do console do navegador (F12)
3. **Status code** da resposta HTTP
4. **Schema atual** do banco:
   ```sql
   \d contracts
   ```
5. **Dados exatos** que est√£o sendo enviados (copie do console)

Com essas informa√ß√µes, podemos identificar o problema exato.

---

## üìö REFER√äNCIAS R√ÅPIDAS

### Comandos √öteis
```bash
# Reiniciar servidor
npm run dev

# Sincronizar schema do banco
npm run db:push

# Acessar console do PostgreSQL (se dispon√≠vel)
psql $DATABASE_URL
```

### Arquivos Cr√≠ticos
- `shared/schema.ts` - Valida√ß√£o Zod e tipos
- `server/routes.ts` - Endpoint de cria√ß√£o
- `server/storage.ts` - L√≥gica de banco
- `client/src/components/admin/ContractForm.tsx` - Formul√°rio
- `vite.config.ts` - Configura√ß√£o do proxy

---

**√öltima atualiza√ß√£o**: Janeiro 2026
**Vers√£o do documento**: 2.0 - Completo e Detalhado